/*
 * Quicktime 4 Linux
 * Copyright (C) 1997-2022 Adam Williams <broadcast at earthling dot net>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 */


#ifndef QTFFMPEG_H
#define QTFFMPEG_H



// This must be separate from qtprivate.h to keep everyone from
// depending on avcodec.h
// FFMPEG front end for quicktime.
// Getting ffmpeg to do all the things it needs to do is so labor
// intensive, we have a front end for the ffmpeg front end.


// This front end is bastardized to support alternating fields with
// alternating ffmpeg instances.  It drastically reduces the bitrate 
// required to store interlaced video but nothing can read it but 
// Heroine Virtual.



#include "avcodec.h"
#include "qtprivate.h"


// video decoding
typedef struct
{
#define FIELDS 2
// Encoding
    AVCodec *encoder[FIELDS];
	AVCodecContext *encoder_context[FIELDS];


// Decoding
    const AVCodec *decoder[FIELDS];
	AVCodecContext *decoder_context[FIELDS];
    AVFrame *picture[FIELDS];

// Last frame generated by the decoder
	int64_t last_frame[FIELDS];

// next frame to feed into the decoder
	int64_t read_position[FIELDS];

// Rounded dimensions
	int width_i;
	int height_i;
// Original dimensions
	int width;
	int height;
	int fields;


// Temporary storage for color conversions
	char *temp_frame;
// Storage of compressed data
	unsigned char *work_buffer;
// Allocation of work_buffer
	int buffer_size;
	int ffmpeg_id;
} quicktime_ffmpeg_t;


// audio decoding
// allocate with calloc
typedef struct
{
    int decoder_initialized;
    int codec_id;
    const AVCodec *decoder;
	AVCodecContext *decoder_context;
	float *temp_buffer;
} quicktime_ffaudio_t;

extern int ffmpeg_initialized;
extern pthread_mutex_t ffmpeg_lock;


quicktime_ffmpeg_t *quicktime_new_ffmpeg(int cpus,
    int use_hw,
	int fields,
    int ffmpeg_id, 
    int w,
    int h,
	quicktime_stsd_table_t *stsd_table); // FFmpeg needs this for the header
void quicktime_delete_ffmpeg(quicktime_ffmpeg_t *ptr);
int quicktime_ffmpeg_decode(quicktime_ffmpeg_t *ffmpeg,
	quicktime_t *file, unsigned char **row_pointers, int track);

void quicktime_ffaudio_init(quicktime_ffaudio_t *ffaudio, int codec_id);
void quicktime_ffaudio_delete(quicktime_ffaudio_t *ffaudio);
int quicktime_ffaudio_decode(quicktime_t *file,
    quicktime_audio_map_t *track_map,
    quicktime_ffaudio_t *ffaudio,
	float *output,
	int64_t samples, 
	int channel);
int quicktime_ffmpeg_get_audio(AVFrame *frame, float *dst);


#endif

